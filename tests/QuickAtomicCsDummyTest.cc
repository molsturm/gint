#include "../../linalgwrap/tests/NumComp.hh"  // TODO This is so quick and dirty ...
#include "SturmianData.hh"
#include <catch.hpp>
#include <gint/IntegralLookup.hh>
#include <linalgwrap/ParameterMap.hh>
#include <linalgwrap/SmallVector.hh>
#include <rapidcheck.h>

namespace gint {
namespace tests {

TEST_CASE("Quick atomic cs_dummy test", "[quicktest]") {
  typedef double scalar_type;
  typedef linalgwrap::SmallMatrix<scalar_type> stored_matrix_type;
  typedef linalgwrap::SmallVector<scalar_type> vector_type;
  const OrbitalType otype = COMPLEX_ATOMIC;
  typedef gint::IntegralLookup<stored_matrix_type, otype> int_lookup_type;
  typedef typename int_lookup_type::integral_matrix_type int_term_type;
  typedef SturmianData<stored_matrix_type> data;

  // Setup parameters for the integral library
  linalgwrap::ParameterMap intparams;
  intparams.update_copy("k_exponent", 1.0);
  intparams.update_copy("Z_charge", 4.0);
  intparams.update_copy("n_max", 3);
  intparams.update_copy("l_max", 2);

  // Setup integral lookup:
  const std::string basis_type("atomic/cs_dummy");
  int_lookup_type integrals(basis_type, intparams);

  // Obtain integral objects:
  int_term_type S_bb = integrals("overlap");
  int_term_type T_bb = integrals("kinetic");
  int_term_type V0_bb = integrals("nuclear_attraction");
  int_term_type J_bb = integrals("coulomb");
  int_term_type K_bb = integrals("exchange");

  // Comparator functor
  typedef linalgwrap::tests::NumComp NumComp;
  double thresh = 1e-12;
  const bool verbose_throw = true;

  // Test generator
  auto make_test = [](const int_term_type& integral,
                      const stored_matrix_type& ref, const double& thresh,
                      const bool verbose_throw) {
    // TODO use matrix generated by rapidcheck instead of a vector here!
    auto test = [&] {
      auto vdata = *rc::gen::container<std::vector<scalar_type>>(
                          integral.n_cols(), rc::gen::arbitrary<scalar_type>())
                          .as("Vector data");
      vector_type vec(vdata);

      RC_ASSERT(NumComp::is_equal_matrix((integral * vec), (ref * vec), thresh,
                                         true, verbose_throw));
    };
    return test;
  };

  // Parameter maps containing coeff

  SECTION("Test overlap") {
    CHECK(S_bb.is_symmetric());
    CHECK(NumComp::is_equal_matrix(S_bb, data::Sref, thresh, true,
                                   verbose_throw));
    CHECK(rc::check("Test application of overlap",
                    make_test(S_bb, data::Sref, thresh, verbose_throw)));
  }

  SECTION("Test nuclear attraction") {
    CHECK(V0_bb.is_symmetric());
    CHECK(NumComp::is_equal_matrix(V0_bb, data::V0ref, thresh, true,
                                   verbose_throw));
    CHECK(rc::check("Test application of nuclear attraction",
                    make_test(V0_bb, data::V0ref, thresh, verbose_throw)));
  }

  SECTION("Test kinetic") {
    CHECK(T_bb.is_symmetric());
    CHECK(NumComp::is_equal_matrix(T_bb, data::Tref, thresh, true,
                                   verbose_throw));
    CHECK(rc::check("Test application of kinetic",
                    make_test(T_bb, data::Tref, thresh, verbose_throw)));
  }

  SECTION("Test coulomb: Test case 1") {
    linalgwrap::ParameterMap map_1;
    map_1.update_copy("coefficients_occupied", data::coeffref_bo_1);
    J_bb.update(map_1);

    CHECK(J_bb.is_symmetric());
    CHECK(NumComp::is_equal_matrix(J_bb, data::Jref_for_coeff_1, thresh, true,
                                   verbose_throw));
    CHECK(rc::check(
          "Test application of coulomb",
          make_test(J_bb, data::Jref_for_coeff_1, thresh, verbose_throw)));
  }

  SECTION("Test coulomb: Test case 2") {
    linalgwrap::ParameterMap map_2;
    map_2.update_copy("coefficients_occupied", data::coeffref_bo_2);
    J_bb.update(map_2);

    CHECK(J_bb.is_symmetric());
    CHECK(NumComp::is_equal_matrix(J_bb, data::Jref_for_coeff_2, thresh, true,
                                   verbose_throw));
    CHECK(rc::check(
          "Test application of coulomb",
          make_test(J_bb, data::Jref_for_coeff_2, thresh, verbose_throw)));
  }

  SECTION("Test exchange: Test case 1") {
    linalgwrap::ParameterMap map_1;
    map_1.update_copy("coefficients_occupied", data::coeffref_bo_1);
    K_bb.update(map_1);

    CHECK(K_bb.is_symmetric());
    CHECK(NumComp::is_equal_matrix(K_bb, data::Kref_for_coeff_1, thresh, true,
                                   verbose_throw));
    CHECK(rc::check(
          "Test application of exchange",
          make_test(K_bb, data::Kref_for_coeff_1, thresh, verbose_throw)));
  }

  SECTION("Test exchange: Test case 2") {
    linalgwrap::ParameterMap map_2;
    map_2.update_copy("coefficients_occupied", data::coeffref_bo_2);
    K_bb.update(map_2);

    CHECK(K_bb.is_symmetric());
    CHECK(NumComp::is_equal_matrix(K_bb, data::Kref_for_coeff_2, thresh, true,
                                   verbose_throw));
    CHECK(rc::check(
          "Test application of exchange",
          make_test(K_bb, data::Kref_for_coeff_2, thresh, verbose_throw)));
  }
}

}  // namespace tests
}  // namespace gint
